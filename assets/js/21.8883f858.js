(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{693:function(v,_,t){v.exports=t.p+"assets/img/design-pattern.2092cde9.png"},759:function(v,_,t){"use strict";t.r(_);var a=t(11),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[v._v("面向对象是"),a("strong",[v._v("武器")])]),v._v(" "),a("p",[v._v("设计模式是"),a("strong",[v._v("招式")])]),v._v(" "),a("p",[v._v("设计原则是"),a("strong",[v._v("心法")])]),v._v(" "),a("p",[v._v("以心法为基础，以武器运用招式应对复杂的编程问题")])]),v._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#什么是设计模式"}},[v._v("什么是设计模式")]),a("ul",[a("li",[a("a",{attrs:{href:"#具有哪些优点"}},[v._v("具有哪些优点")])]),a("li",[a("a",{attrs:{href:"#四要素"}},[v._v("四要素")])])])]),a("li",[a("a",{attrs:{href:"#分类"}},[v._v("分类")]),a("ul",[a("li",[a("a",{attrs:{href:"#创建型设计模式"}},[v._v("创建型设计模式")]),a("ul",[a("li",[a("a",{attrs:{href:"#相同点"}},[v._v("相同点")])]),a("li",[a("a",{attrs:{href:"#不同点"}},[v._v("不同点")])])])]),a("li",[a("a",{attrs:{href:"#结构型设计模式"}},[v._v("结构型设计模式")]),a("ul",[a("li",[a("a",{attrs:{href:"#相同点"}},[v._v("相同点")])]),a("li",[a("a",{attrs:{href:"#不同点"}},[v._v("不同点")])])])]),a("li",[a("a",{attrs:{href:"#行为型设计模式"}},[v._v("行为型设计模式")]),a("ul",[a("li",[a("a",{attrs:{href:"#相同点"}},[v._v("相同点")])]),a("li",[a("a",{attrs:{href:"#不同点"}},[v._v("不同点")])])])])])])])]),a("p"),v._v(" "),a("h2",{attrs:{id:"什么是设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是设计模式"}},[v._v("#")]),v._v(" 什么是设计模式")]),v._v(" "),a("p",[v._v("设计模式最早来源于建筑领域")]),v._v(" "),a("blockquote",[a("p",[v._v('克里斯托弗.亚历山大在作品《建筑的永恒之道》中这样说："每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无须再重复相同的工作。"')])]),v._v(" "),a("p",[v._v("之后四人组（Gang of Four，简称GoF）将模式的概念应用在软件开发设计中，定义如下：")]),v._v(" "),a("blockquote",[a("p",[v._v("它是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。")]),v._v(" "),a("p",[v._v("它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。")])]),v._v(" "),a("p",[v._v("简单来说，就是"),a("strong",[v._v("解决特定问题的一系列解决方案")]),v._v("，是前辈们的代码设计经验的总结。")]),v._v(" "),a("h3",{attrs:{id:"具有哪些优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#具有哪些优点"}},[v._v("#")]),v._v(" 具有哪些优点")]),v._v(" "),a("ul",[a("li",[v._v("优化软件设计：设计模式通常由经验丰富的开发者提供实现，可以提高软件的可重用性、可扩展性和可维护性。")]),v._v(" "),a("li",[v._v("提高软件质量：设计模式通常会规范代码编写，有助于减少代码中的错误和问题。")]),v._v(" "),a("li",[v._v("提高团队协作效率：设计模式具有通用性和标准化，从而使团队成员更容易合作编写代码，提高协作效果。")]),v._v(" "),a("li",[v._v("提高系统性能：设计模式可以优化代码实现，提高系统性能。")])]),v._v(" "),a("h3",{attrs:{id:"四要素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四要素"}},[v._v("#")]),v._v(" 四要素")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("问题")]),v._v("：问题或称为上下文、场景，指在软件开发中需要解决的某个问题或需求。设计模式通常解决针对特定上下文或场景中出现的问题。")]),v._v(" "),a("li",[a("strong",[v._v("解决方案")]),v._v("：解决方案或称为模型、模式，是指用于解决上述问题的通用方法或最佳实践。设计模式描述了解决某问题的方法或模板，并提供了这些方法的实现细节，使得类似问题可以被解决且易于复用。")]),v._v(" "),a("li",[a("strong",[v._v("效果")]),v._v("：效果或称为结果、贡献，是指使用该模式带来的好处和优点。设计模式提供了可重用、灵活的解决方案，增加可维护性、可扩展性和可重用性。")]),v._v(" "),a("li",[a("strong",[v._v("元素")]),v._v("：元素或称为参与者、角色、类和对象，组成了设计模式的各个部分。这些元素可以是类、对象、接口、方法等等。元素描述了在特定上下文或场景中参与模式实现的各种组件。")])]),v._v(" "),a("h2",{attrs:{id:"分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[v._v("#")]),v._v(" 分类")]),v._v(" "),a("p",[a("img",{attrs:{src:t(693),alt:"分类"}})]),v._v(" "),a("h3",{attrs:{id:"创建型设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建型设计模式"}},[v._v("#")]),v._v(" 创建型设计模式")]),v._v(" "),a("blockquote",[a("p",[v._v("创建型设计模式是一种常用的设计模式，常用于对象的创建和初始化，这些模式描述了创建对象的不同方式，以及处理对象创建的方案。")])]),v._v(" "),a("h4",{attrs:{id:"相同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[v._v("#")]),v._v(" 相同点")]),v._v(" "),a("ul",[a("li",[v._v("都可以抽象和封装对象的创建过程；")]),v._v(" "),a("li",[v._v("在代码中高度模块化，提高了代码的重用性和可维护性；")]),v._v(" "),a("li",[v._v("通过减轻了耦合关系，可以降低系统的复杂度；")]),v._v(" "),a("li",[v._v("为对象创建提供了规范化的方式，使得对象的创建更加简单易懂。")])]),v._v(" "),a("h4",{attrs:{id:"不同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不同点"}},[v._v("#")]),v._v(" 不同点")]),v._v(" "),a("ul",[a("li",[v._v("单例模式旨在确保一个类只有一个实例，通过提供全局唯一的实例，方便对实例的管理和调用；")]),v._v(" "),a("li",[v._v("工厂模式旨在将对象的创建和对象本身分离开来，确保对象的创建过程不会影响代码的其他部分；")]),v._v(" "),a("li",[v._v("抽象工厂模式在工厂方法模式的基础上，为不同类型的工厂方法定义了一个抽象的父类，使工厂拥有高度的可扩展性；")]),v._v(" "),a("li",[v._v("建造者模式旨在将对象的创建过程拆分成多个部分，通过组合的方式实现最终对象的创建；")]),v._v(" "),a("li",[v._v("原型模式旨在通过克隆已有对象的方式来创建新的对象，以避免重复的对象创建过程。")])]),v._v(" "),a("h3",{attrs:{id:"结构型设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结构型设计模式"}},[v._v("#")]),v._v(" 结构型设计模式")]),v._v(" "),a("blockquote",[a("p",[v._v("结构型设计模式是一组用于组织类和对象之间关系的设计模式，它们通常用于提高代码的可维护性、可扩展性和可重用性。结构型设计模式分为"),a("code",[v._v("类结构型模式")]),v._v("和"),a("code",[v._v("对象结构型模式")]),v._v("。")])]),v._v(" "),a("p",[v._v("其中：")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("类结构型模式")]),v._v("关注类之间的组合，例如装饰器模式、适配器模式、代理模式等；而"),a("code",[v._v("对象结构型模式")]),v._v("关注对象之间的组合，例如组合模式、享元模式等。")]),v._v(" "),a("li",[a("code",[v._v("类结构型模式")]),v._v("更侧重于对象之间的静态关系，即在编译时期已经确定相关类之间的关系，而"),a("code",[v._v("对象结构型模式")]),v._v("更侧重于对象之间的动态关系，即在运行时期可以动态添加或移除对象。")]),v._v(" "),a("li",[a("code",[v._v("类结构型模式")]),v._v("的使用场景更为广泛，适用于不同的问题领域；而"),a("code",[v._v("对象结构型模式")]),v._v("更加专注于一些具体的问题场景。")])]),v._v(" "),a("h4",{attrs:{id:"相同点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相同点-2"}},[v._v("#")]),v._v(" 相同点")]),v._v(" "),a("ul",[a("li",[v._v("都可以用于组织和组合类之间的关系；")]),v._v(" "),a("li",[v._v("在代码中提供了高度模块化的方式，便于代码的重用和维护；")]),v._v(" "),a("li",[v._v("通过组合、代理、继承等方式，可以更加灵活地设计类的层次结构；")]),v._v(" "),a("li",[v._v("可以降低系统的复杂度，提高代码的可读性和可维护性。")])]),v._v(" "),a("h4",{attrs:{id:"不同点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不同点-2"}},[v._v("#")]),v._v(" 不同点")]),v._v(" "),a("ul",[a("li",[v._v("代理模式旨在控制对对象的访问，为使用者提供简化的接口，同时也可以提升对象的访问效率；")]),v._v(" "),a("li",[v._v("适配器模式旨在将不同对象之间的接口协调起来，使它们能够协同工作；")]),v._v(" "),a("li",[v._v("桥接模式旨在将类的抽象和实现分离出来，使得两者可以独立地变化；")]),v._v(" "),a("li",[v._v("装饰器模式旨在动态地添加类的额外行为，而无需修改类的接口和实现；")]),v._v(" "),a("li",[v._v("外观模式旨在将一组紧密相关的类中的复杂逻辑抽象出来，提供一个简单的接口给使用者；")]),v._v(" "),a("li",[v._v("享元模式旨在共享多个具有相同状态的对象，以减少内存的占用。")])]),v._v(" "),a("h3",{attrs:{id:"行为型设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行为型设计模式"}},[v._v("#")]),v._v(" 行为型设计模式")]),v._v(" "),a("blockquote",[a("p",[v._v("行为型设计模式是一类用于处理对象之间交互、职责划分以及算法封装等问题的设计模式，这类设计模式关注的是对象之间的通信以及行为的分配，可以帮助解决对象之间职责不够清晰、相互依赖、难以复用等问题。")])]),v._v(" "),a("h4",{attrs:{id:"相同点-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相同点-3"}},[v._v("#")]),v._v(" 相同点")]),v._v(" "),a("ul",[a("li",[v._v("都是用于描述和组织对象的行为和交互方式；")]),v._v(" "),a("li",[v._v("通过将复杂的交互拆分成多个独立的部分，提高代码的重用性和可维护性；")]),v._v(" "),a("li",[v._v("用于降低对象之间的耦合度，提高代码的可扩展性和灵活性；")]),v._v(" "),a("li",[v._v("通过定义抽象接口和规范方法调用方式，提高代码的规范性和可读性。")])]),v._v(" "),a("h4",{attrs:{id:"不同点-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不同点-3"}},[v._v("#")]),v._v(" 不同点")]),v._v(" "),a("ul",[a("li",[v._v("观察者模式旨在实现对象之间的松耦合关系，当一个对象状态发生改变时，它会通知它所观察到的所有对象；")]),v._v(" "),a("li",[v._v("模板方法模式旨在将通用的算法框架定义为一个抽象函数，然后由子类实现具体算法的不同部分；")]),v._v(" "),a("li",[v._v("策略模式是定义一族算法、封装每个算法，并使这些算法可以互换，从而让算法的变化独立于客户端；")]),v._v(" "),a("li",[v._v("命令模式旨在将请求封装成对象，以便于参数化和传递，同时支持请求排队、记录日志、撤销等操作；")]),v._v(" "),a("li",[v._v("责任链模式旨在将请求的处理方式连成一个链，每个对象都尝试处理该请求，直到其中一个对象处理成功为止；")]),v._v(" "),a("li",[v._v("迭代器模式是在不暴露集合内部结构的情况下，提供一种访问元素的方式；")]),v._v(" "),a("li",[v._v("访问者模式则是定义了一组对数据结构中的元素进行操作的方法，通过这些方法可以实现对数据结构的统一处理。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);