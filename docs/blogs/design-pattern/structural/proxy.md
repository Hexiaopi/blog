---
title: 设计模式-代理
date: 2022-12-10
tags:
 - Go
 - 设计模式
categories:
 -  设计模式
---

![proxy](https://refactoringguru.cn/images/patterns/content/proxy/proxy-2x.png)

<!-- more -->

## 代理模式

> 代理模式(Proxy Pattern):由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

![代理模式](../images/proxy.png)

### 使用场景

代理设计模式是一种非常常见的设计模式，它通常用于以下场景：

- 远程代理：当一个对象位于不同的地址空间（例如在不同的服务器上）时，为了让客户端能够访问该对象，可以使用远程代理来实现。

- 虚拟代理：当一个对象的创建或者加载时需要很长时间，可以使用虚拟代理来延迟对象的加载或者创建，直到真正需要使用该对象时再进行加载或者创建。

- 安全代理：当对一个对象的访问需要进行安全控制时，可以使用安全代理来控制对象的访问权限，例如在对象被访问时需要进行认证或授权等。

- 缓存代理：当需要缓存一些计算结果时，可以使用缓存代理，以便在后续的访问中直接返回缓存的结果，避免重复计算。

- 日志记录代理：在访问被代理对象的过程中，使用日志记录代理可以记录所有访问记录，以便于问题排查和系统优化等。

- 延迟初始化代理：当一个对象的初始化很耗时时，可以使用延迟初始化代理来实现，将对象的初始化推迟到真正需要使用该对象时再进行初始化，避免浪费资源。

总之，代理设计模式适用于很多场景，包括访问远程对象、控制访问权限、缓存计算结果、日志记录、延迟初始化等。因此，在实际开发中，可以根据具体的应用场景来选择使用代理设计模式。

### 角色

- Subject: 抽象主题，通过接口或抽象类声明真实主题和代理对象实现的业务方法
- RealSubject: 真实主题，实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象
- Proxy: 代理类，提供了与真实主题相同的接口，其内部包含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

### 示例

```go
package proxy

import "fmt"

type Subject interface {
	Request()
}

type RealSubject struct {
}

func (r RealSubject) Request() {
	fmt.Println("do request")
}

type Proxy struct {
	realSubject Subject
}

func (p *Proxy) preRequest() {
	fmt.Println("pre request")
}

func (p *Proxy) postRequest() {
	fmt.Println("post request")
}

func (p *Proxy) Request() {
	p.preRequest()
	p.realSubject.Request()
	p.postRequest()
}
```
使用示例如下：
```go
package proxy

func ExampleRequest() {
	var subject Subject
	subject = Proxy{realSubject: RealSubject{}}
	subject.Request()
	// Output:
	// pre request
	// do request
	// post request
}
```

### 优点

- 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度
- 远程代理使得客户端可以访问在远程机器上的对象，远程机器坑具有更好的计算性能与处理速度，可以加快相应并处理客户端请求
- 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度
- **保护代理**可以控制对真实对象的使用权限

### 缺点

- 由于客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢
- 实现代理模式需要额外的工作，有些代理模式的实现非常复杂

### 对比

#### 代理模式和装饰器模式

代理设计模式和装饰器模式是非常相似的两个模式。

装饰器模式也是一种结构型模式，它允许您向现有对象添加新的功能，而不必改变其结构。代理模式同样也允许您向现有对象添加新的功能，同时也保持原有结构不变。实际上，代理模式就是装饰器模式的一种变体，其核心思想是为了控制访问某个对象，而不是像装饰器模式那样用于扩展对象的功能。

在两种模式中，都需要实现与被代理对象（或被装饰对象）相同的接口。代理模式通过代理对象操纵被代理对象，控制对被代理对象的访问，而装饰器模式则是通过包装器对象来扩展被装饰对象的功能，但对于客户端来说，无论是使用代理对象还是装饰器对象，都是透明的，客户端无法直接感知到代理对象或装饰对象的存在。

总之，代理设计模式和装饰器模式都能够实现动态的扩展对象的功能和控制对象的访问，两者高度相似。代理模式强调的是为了控制访问某个对象，而装饰器模式强调的是为了扩展对象的功能。

#### 代理模式和 Middleware

代理设计模式和 Middleware 之间存在相似之处，这两个模式都是为了实现对象间松耦合，增强维护性和扩展性。

相同点：

- 两者都是用于控制系统中各个组件之间的访问和交互。
- 两者都可以在访问和交互时执行额外的操作，例如身份验证、日志记录、路由配置等等。

不同点：

- 代理设计模式通常用于控制客户端和服务端之间的访问，解耦客户端和服务端。而 Middleware 通常用于控制不同层之间的访问和处理，例如日志记录、缓存处理和性能优化等。
- 在代理设计模式中，代理对象需要实现被代理对象相同的接口和方法。而 Middleware 不需要实现任何接口或方法，每个 Middleware 都是独立的，但需要一起协作来处理请求。
